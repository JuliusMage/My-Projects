version: '3.8'

services:
  postgres_db:
    image: postgres:15-alpine
    container_name: ${COMPOSE_PROJECT_NAME:-ai_support}_postgres_db
    environment:
      POSTGRES_USER: ${DB_USER:-admin}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-secret}
      POSTGRES_DB: ${DB_NAME:-support_dashboard_db}
    ports:
      - "${DB_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - support_net
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-admin} -d $${POSTGRES_DB:-support_dashboard_db}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped

  redis_cache:
    image: redis:7-alpine
    container_name: ${COMPOSE_PROJECT_NAME:-ai_support}_redis_cache
    ports:
      - "${REDIS_PORT:-6379}:6379"
    command: >
      sh -c "redis-server --save 20 1 --loglevel warning ${REDIS_PASSWORD:+--requirepass \"$REDIS_PASSWORD\"}"
    volumes:
      - redis_data:/data
    networks:
      - support_net
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD:-}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped

  backend-api:
    build:
      context: . # Monorepo root as context
      dockerfile: services/backend-api/Dockerfile
    container_name: ${COMPOSE_PROJECT_NAME:-ai_support}_backend_api
    env_file:
      - .env # Root .env file for Docker Compose variable substitution
      # The Dockerfile's ENV NODE_ENV production will take precedence if not overridden here.
      # Service specific .env can be loaded by the app itself if path is configured or by setting vars below.
    environment:
      # These variables are passed into the container.
      # They override .env file values loaded by docker-compose itself for substitution,
      # and are available to the application running inside the container.
      NODE_ENV: ${NODE_ENV:-development} # For app running inside container
      API_PORT: ${API_PORT:-3000}

      DB_HOST: postgres_db # Use service name for Docker internal network
      DB_PORT: 5432 # Internal port for PostgreSQL
      DB_USER: ${DB_USER:-admin}
      DB_PASSWORD: ${DB_PASSWORD:-secret}
      DB_NAME: ${DB_NAME:-support_dashboard_db}
      TYPEORM_SYNCHRONIZE: ${TYPEORM_SYNCHRONIZE:-true} # Default to true for local docker-compose ease

      REDIS_HOST: redis_cache # Service name for Docker internal network
      REDIS_PORT: 6379 # Internal port for Redis
      REDIS_PASSWORD: ${REDIS_PASSWORD} # Will be empty if not set in .env

      JWT_SECRET: "${JWT_SECRET}" # Ensure quotes if secret might have special chars
      JWT_REFRESH_SECRET: "${JWT_REFRESH_SECRET}"
      JWT_ACCESS_TOKEN_EXPIRATION: ${JWT_ACCESS_TOKEN_EXPIRATION:-15m}
      JWT_REFRESH_TOKEN_EXPIRATION: ${JWT_REFRESH_TOKEN_EXPIRATION:-7d}

      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3001}
      OPENAI_API_KEY: "${OPENAI_API_KEY}"
      LLM_PROVIDER: ${LLM_PROVIDER:-openai}
      LOCAL_LLM_URL: ${LOCAL_LLM_URL}

      # Add any other environment variables required by your NestJS app's ConfigModule validation
      LOG_LEVEL: ${LOG_LEVEL:-debug}

    ports:
      - "${API_PORT:-3000}:${API_PORT:-3000}" # Host port:Container port
      - "9229:9229" # For Node.js debugging (map container's 9229 to host's 9229)
    volumes:
      # The Dockerfile is set up for a build-once-run-anywhere approach.
      # For local development with hot-reloading, you'd typically:
      # 1. Have a dev stage in Dockerfile that installs devDependencies.
      # 2. Mount source code:
      #    - ./services/backend-api:/opt/app/services/backend-api
      #    - ./packages/shared-types:/opt/app/packages/shared-types
      # 3. Use a CMD like "pnpm --filter backend-api start:dev" or "pnpm --filter backend-api start:debug"
      # 4. Ensure node_modules in container is not overwritten by host:
      #    - /opt/app/services/backend-api/node_modules
      # This current setup is more for a production-like container.
      # For debugging, ensure your NestJS app starts in debug mode if needed (e.g. via start:debug script).
      - /opt/app/services/backend-api/node_modules # Anonymous volume to ensure container's node_modules aren't overwritten by potential host mounts (good practice)
    depends_on:
      postgres_db:
        condition: service_healthy
      redis_cache:
        condition: service_healthy
    networks:
      - support_net
    # The CMD in the Dockerfile is `node dist/main.js`.
    # If you need to run migrations before starting, you could use a custom script:
    # command: >
    #  sh -c "
    #    echo 'Running TypeORM migrations...' &&
    #    pnpm --filter backend-api typeorm migration:run &&
    #    echo 'Starting NestJS application...' &&
    #    node services/backend-api/dist/main.js
    #  "
    # For this, pnpm and typeorm CLI would need to be in the production image.
    # The current Dockerfile's production stage is very lean.
    # Alternatively, migrations can be run as a separate one-off task against the DB.
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local

networks:
  support_net:
    driver: bridge
